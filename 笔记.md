### 复杂度
### 位运算
> https://github.com/xianren68/Introduction-to-algorithm/tree/main/bitwise
#### 异或
> 异或运算的性质
> 1. 相同的数异或为0，一个数和0异或为它本身
> 2. 异或运算满足交换率和结合率

**注意：go中没有按位与的符号，可以通过^n来实现**
**取某个数n的最右边的1**`rightone := n&(^n+1)`
###### 拓展
```
1. 一个数组，只有一个数为奇数个，其他均为偶数个，求这个数
2. 一个数组中，有两个数位奇数个，求这两个数
```
### 排序
> https://github.com/xianren68/Introduction-to-algorithm/tree/main/basic_sort
#### 1.选择排序
> 从0开始进行n次循环，每次循环从当前值到数组末位，选择出一个最大或最小的值与当前位置进行交换
> 时间复杂度O(n^2)，空间复杂度o(1)
#### 2.冒泡排序
> 与选择排序相似，每次循环找出最小或最大的值，将其移动到数组末位，不过选择排序会记录最小或最大的值
> 一次循环只进行一次交换，而冒泡排序则对相邻元素比较，交换
> 时间复杂度o(n^2),没有占用额外空间
#### 3.插入排序
> 将要排序的值插入到已排序的值中，从第二值个开始遍历数组，将当前值前面的数作为已排序的序列，将当前值插入其中，
> 从而让有序序列的长度再次加1，然后再继续向下遍历,相比较于前面两个排序，插入排序的性能因为数据而有所不同，
> 当数据较为有序时，它的遍历次数会小很多，而选择与冒泡不会发生变化
> 时间复杂度o(n^2),没有占用额外空间
#### 4.归并排序
> 通过递归的方式，将给定的数据分为左右两个序列，分别让它们有序，然后将其合并，形成一个新的有序序列
> 时间复杂度,根据master公式为O(N*logN)
#### 5.快速排序
> 1.荷兰国旗问题：给定一个数组，并给定一个值num，将比num大的数放到数组前段，将=num的数放到数组中段，大于
> num的数放到数组后段
> 解法：
> 1. 给定两个指针l,r,用来指定<区的后一位和>区的前一位
> 2. 通过索引i遍历数组,如果小于num,将当前位置与l位置交换，扩充<区，l++
> 3. 如果小于num,将当前位置与l位置交换，扩充>区，r--,不知道交换回值的大小，所以i应保持不变
> 4. 当i=r时，所有的数已经排列完毕
###### 快速排序2.0：
>1. 将数组的最后一位作为指定数，然后通过递归将数组转化为三块，再将指定数放到等于区
>2. 通过递归将数组各个部分都执行上述操作，最后得到有序的数组
###### 快速排序3.0：
>因为2.0版本的快排很受数据的影响，时间复杂度为O(n^2),3.0基于2.0将指定数num从最后一位，换成随机取，然后再与最后
>一位进行交换，因为随机，所以不会收数据影响，时间复杂度为O(n * logN)
>       
>
###### 拓展
```
1.求一个数组的小和 数组小和的定义如下：
例如，数组s = [1, 3, 5, 2, 4, 6]，在s[0]的左边小于或等于s[0]的数的和为0；在s[1]的左边小于或等于s[1]的数的和为1；在s[2]的左边小于或等于s[2]的数的和为1+3=4；在s[3]的左边小于或等于s[3]的数的和为1；
在s[4]的左边小于或等于s[4]的数的和为1+3+2=6；在s[5]的左边小于或等于s[5]的数的和为1+3+5+2+4=15。所以s的小和为0+1+4+1+6+15=27
给定一个数组s，实现函数返回s的小和
2.求数组逆序对
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对
```
```
marst公式
在计算涉及递归的算法的时候，计算复杂度就会变得有些麻烦。Master公式就是用来进行剖析递归行为和递归行为时间复杂度的估算的

Master公式：T(N) = a*T(N/b) + O(N^d)

公式解释：n表示问题的规模，a表示递归的次数也就是生成的子问题数，N/b表示子问题的规模。O(N^d)表示除了递归操作以外其余操作的复杂度

结论（证明省略）：
①当d<logb a时，时间复杂度为O(N^(logb a))
②当d=logb a时，时间复杂度为O((N^d)*logN)
③当d>logb a时，时间复杂度为O(N^d)

注意：子问题规模必须等分，不管你是分成几部分
```
### 查找
#### 1.二分法
> 通常用来在有序集合中查找某个值，将数组为三，当前值，左边的，右边的
> 如果当前值是要找的值，则直接返回，否则判断左右哪个符合条件，再将其一分为3继续重复上述过程
> 最后总能找到要查找的值，时间复杂度O(logN)
> 其实只要能确定要查找的值必然在数组分隔的两端
> 就可以用二分法
###### 拓展
```
一个数组，求局部最小值(左右都比当前值大)
```
